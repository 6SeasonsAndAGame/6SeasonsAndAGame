// Copyright(c) 2017 Venugopalan Sreedharan. All rights reserved.

#pragma once

#include "DonMeshPaintingDefinitions.h"

#include "DonMeshPainterGlobalActor.generated.h"

/** 
*    This is the cornerstone of Skeletal-Mesh/Character Painting workflow.
      Contains the position texture carrying baked pixel positions per material.
*    These are used to perform various lookups inside the material (for seamless painting) and outside of it too (for decal projection)
**/
struct FDonMeshPositionsPerMaterial
{
	class UTextureRenderTarget2D* PositionsTexture = nullptr;
	class UTextureRenderTarget2D*DilatedPositionsTexture = nullptr;

	FDonMeshPositionsPerMaterial(){}
	FDonMeshPositionsPerMaterial(class UTextureRenderTarget2D* InPositionsTexture, class UTextureRenderTarget2D* InDilatedPositionsTexture) :
	PositionsTexture(InPositionsTexture), DilatedPositionsTexture(InDilatedPositionsTexture)	{}
};

// Type for cached pixel data
typedef TArray<FFloat16Color> DonPositionPixels;

/**
* The Global Painter ACtor performs various common tasks including:
* + Replication management for actors that don't replicate by default (Eg: Landscape)
* + Painter Component book-keeping, dynamic assignment of painter components to Actors that own a paintable primitive
* + Positions Texture generation and management
* + Render Target management
* + Smart Log Memorization
*/
UCLASS()
class DONMESHPAINTING_API ADonMeshPainterGlobalActor : public AActor
{
	GENERATED_BODY()

public:

	ADonMeshPainterGlobalActor(const FObjectInitializer& ObjectInitializer);

	UPROPERTY()
	class USceneComponent* SceneRoot;

	// ~~~ Positions Texture Generation & Management ~~~

	/** Positions Capture component */
	UPROPERTY()
	class USceneCaptureComponent2D* UVPositionsCaptureComponent;

	/** This is the material that "unwraps" a mesh in 3D space allowing the capture component to generate a texture from it*/
	UPROPERTY()
	class UMaterialInterface* UnwrapperMaterial;

	/** Used to enable seamless painting by dilating the positions texture generated by the unwrapper*/
	UPROPERTY()
	class UMaterialInterface* DilationMaterial;

	/** Utility material used to hide materials that should not participate in the baking process at a given frame*/
	UPROPERTY()
	class UMaterialInterface* HiddenMaterial;	

	UPROPERTY()
	class UMaterialInterface* SaveTextureToRTMaterial;	

	/** Dynamic material instances:*/
	UPROPERTY()
	class UMaterialInstanceDynamic* UnwrapperMaterialInstance;

	UPROPERTY()
	class UMaterialInstanceDynamic* DilationMaterialInstance;

	UPROPERTY()
	class UMaterialInstanceDynamic* SaveTextureToRTMaterialInstance;	

	//

	/** This is the material with which actual texture painting is performed via the "Draw Material To Render Target" call*/
	UPROPERTY()
	class UMaterialInterface* DefaultBrushRenderMaterial;

	UPROPERTY()
	class UMaterialInterface* EraserBrushRenderMaterial;	

	/** Used to setup World Space painting for a given map, contains the World Min, World Max attributes used for achieving world-space planar mapping*/
	UPROPERTY()
	class UMaterialParameterCollection* GlobalMeshPaintingParameters;	

	/*
	* Retrieves the relative space positions packed into a texture UV-ed along the Mesh's specified UV channel
	*
	* Mesh - The mesh for which relative positions are to be extracted
	* MaterialIndex - The material for which positions are being baked. As each material has a different UV map it also needs a separate positions texture.
	* UV Channel - The UV Channel to be used while laying out the positions onto the resultant texture
	* ReferenceBounds - Bounds for skeletal meshes are not fixed, they keep changing as the character moves. 
	                                 Therefore this variable helps memorize the exact bounds with which a positions texture was generated. Only these bounds can be used for any lookup/calculation on that texture.
	*/
	class UTextureRenderTarget2D* GetPositionsTextureForMesh(class UPrimitiveComponent* Mesh, const int32 MaterialIndex, const int32 UvChannel, const FBoxSphereBounds ReferenceBounds);

	void CachePositionsTexture(class UTextureRenderTarget2D* PositionsTexture, class UPrimitiveComponent* PrimitiveComponent, const int32 MaterialIndex);
	bool UvFromCachedPositionsTexture(FVector2D& OutUV, class UTextureRenderTarget2D* PositionsTexture, const FBoxSphereBounds ReferenceBounds, FVector RelativePosition, class UPrimitiveComponent* PrimitiveComponent, const int32 MaterialIndex);


	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

private:
	TMap<class UPrimitiveComponent*, TArray<FDonMeshPositionsPerMaterial>> PositionsTextureCache;

	UPROPERTY()
	TMap<class UObject*, UPrimitiveComponent*> PositionsTextureMeshes;

	UPROPERTY()
	TArray<UPrimitiveComponent*> CommonPositionCaptureMeshes;

	static const uint32 DefaultPositionsTextureSizeX = 512;
	static const uint32 DefaultPositionsTextureSizeY = 512;
	
private:
	// Positions Cache (Advanced usecase: Projecting decals for skeletal meshes via position texture lookup!)	
	TMap<UPrimitiveComponent*, TArray<DonPositionPixels>> PositionsAsPixelsCache;

	// Render materials Cache (avoid creating a new MID each brush stroke)
	TMap<class UMaterialInterface*, class UMaterialInstanceDynamic*> RenderMaterialsCache;

	// GC Management:
	UPROPERTY(ReplicatedUsing=OnRep_ActivePainterComponents)
	TArray<class UDonMeshPainterComponent*> ActivePainterComponents;

	UPROPERTY()
	TArray<class UTextureRenderTarget2D*> ActiveRenderTargets;

	UPROPERTY()
	TArray<class UMaterialInstanceDynamic*> ActiveRenderMaterials;

	// Networking:
	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty> & OutLifetimeProps) const override;

	UFUNCTION()
	void OnRep_ActivePainterComponents();

public:

	FORCEINLINE TArray<class UDonMeshPainterComponent*> GetActivePainterComponents() { return ActivePainterComponents;	}
	FORCEINLINE void RegisterPainterComponentIfMissing(UDonMeshPainterComponent* PainterComponent) { ActivePainterComponents.AddUnique(PainterComponent); }
	// TSet would be faster here, but num items is expected to be low

	void FlushAllPaint();

	// Currently unused
	UFUNCTION(NetMulticast, Reliable)
	void MultiCast_FlushAllPaint();

	class UMaterialInstanceDynamic* GetCachedRenderMaterial(class UMaterialInterface* RenderMaterial);

	class AActor* GetMeshPaintingOwnerActor(AActor* PaintableActor);
	class UDonMeshPainterComponent* GetMeshPainterComponent(AActor* PaintableActor);

	// World Space Painting:
	UPROPERTY()
	class UTextureRenderTarget2D* RenderTargetWorldSpaceXY;

	class UTextureRenderTarget2D* LoadWorldSpacePaintingMetadata(const EDonUvAxes WorldAxes, const int32 LayerIndex);
	void LogWorldSpaceAssetMissingError(const FString AssetPath);

	// For Debugging:
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Don Mesh Painting Debug")
	UTexture* CurrentUnwrap;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Don Mesh Painting Debug")
	UMaterialInterface* CurrentAdditiveBrush;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Don Mesh Painting Debug")
	UMaterialInterface* LastPaintedMaterial;

	void EnsureInitialSetup();

protected:
	virtual void BeginPlay() override;
	
#if !UE_BUILD_SHIPPING	
	//
	// ~~~ Smart Logging with memorization:~~~
	//

private:
	// These smart log caches that ensure users don't get spammed with messages they've already seen
	TSet<TWeakObjectPtr<class APawn>> LogCache_PawnsWithKnownSetupIssues;
	TSet<TWeakObjectPtr<class UMaterialInterface>> LogCache_MaterialsWithKnownSetupIssues;
	TSet<FString> LogCache_WorldSpaceAssetsWithKnownPathIssues;

public:
	bool bLandscapeUvMethodWarningShown = false;
	bool bWorldBoundsDebugBoxShown = false;

	FORCEINLINE void LogMemorize_MaterialWithSetupIssue(class UMaterialInterface* Material) { LogCache_MaterialsWithKnownSetupIssues.Add(Material); }		
	FORCEINLINE void LogMemorize_PawnWithSetupIssue(class APawn* Pawn) { LogCache_PawnsWithKnownSetupIssues.Add(Pawn); }
	FORCEINLINE bool IsMaterialWithKnownSetupIssues(class UMaterialInterface* Material) { return LogCache_MaterialsWithKnownSetupIssues.Contains(Material); }
	FORCEINLINE bool IsPawnWithKnownSetupIssues(class APawn* Pawn) { return LogCache_PawnsWithKnownSetupIssues.Contains(Pawn); }
	bool IsPawnWithKnownSetupIssues(UObject* PaintableComponent);
#endif // UE_BUILD_SHIPPING

	// Render Target Pooling for one-time usecases:
private:
	UPROPERTY()
	TArray<class UTextureRenderTarget2D*> RenderTargetPool;

public:
	class UTextureRenderTarget2D* GetRenderTargetFromPool(class UTextureRenderTarget2D* Template);

	UPROPERTY(Category = Mesh, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class USkeletalMeshComponent* DebugCaptureMesh;
};
